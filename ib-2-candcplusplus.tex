\documentclass{tripos}
\begin{document}
\begin{question}[MockIA,year=2025,paper=2,question=2,author=nobody]{Programming in C and C++}
%%\emph{\ldots Awaiting question 2 on Programming in C and C++}
  \triposset{fullmarks=20}
  \topic{Programming in C and C++}

  The Burroughs-Wheeler transform on a string is defined like this:

  \begin{itemize}
    \item Add an EOF character.
    \item Compute all the circular shifts of the string.
    \item Sort them
    \item Extract the last column
  \end{itemize}

  And its inverse, taking the output of the forward transform as a string, is:

  \begin{itemize}
  \item Create an empty table
  \item Repeat length(s) times
    \begin{itemize}
    \item Insert s as a column of the table before the current first column
    \item Sort rows of the table
    \end{itemize}
  \item Return the row of the table which ends with EOF.
  \end{itemize}

  \begin{enumerate}
  \item Implement the Burroughs-Wheeler transform in C++ with prototype:
\begin{verbatim}
   void bwt(const std::string& input, unsigned char *output);
\end{verbatim}
Briefly describe the contract and constraints for your implementation and explain how it exploits the features of C and C++ for efficiency.
\fullmarks{12}
\item There's no guarantee that a \verb|char| is the right size to sort by. Briefly explain how to adapt your implementation (in C++) for arbitrary input and output types. Explain how C++ allows you to do this more efficiently than, say, Java, and outline some of the associated drawbacks. \fullmarks{6}
\item Should you ever write \verb|const uint32_t&| ? \fullmarks{2}
\end{enumerate}
%%\typeout{Awaiting question 2 on Programming in C and C++}
\end{question}
\eject
\end{document}
